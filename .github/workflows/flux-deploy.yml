# Reusable workflow for deploying applications via GitOps using Flux
# Location: github-workflows repo at .github/workflows/flux-deploy.yml

name: Flux GitOps Deploy

on:
  workflow_call:
    inputs:
      app_name:
        required: true
        type: string
        description: 'Name of the application'
      image_tag:
        required: true
        type: string
        description: 'Docker image tag to deploy'
      target_namespace:
        required: true
        type: string
        description: 'Target namespace (kio-dev, kio-prod, etc.)'
      gitops_repo:
        required: true
        type: string
        description: 'GitOps repository (owner/repo)'
      cluster_path:
        required: true
        type: string
        description: 'Path to cluster configuration in GitOps repo'
      cluster_name:
        required: true
        type: string
        description: 'Name of the target cluster'
      commit_message_suffix:
        default: ''
        type: string
        description: 'Additional suffix for commit message'
    secrets:
      CICD_TOKEN:
        required: true
      CICD_USER_EMAIL:
        required: true
      CICD_USER_NAME:
        required: true

jobs:
  deploy:
    runs-on: arc-runners-javadev
    steps:
      - name: Deploy via GitOps
        run: |
          set -e
          
          GITOPS_REPO="${{ inputs.gitops_repo }}"
          APP_NAME="${{ inputs.app_name }}"
          NAMESPACE="${{ inputs.target_namespace }}"
          IMAGE_TAG="${{ inputs.image_tag }}"
          CLUSTER_PATH="${{ inputs.cluster_path }}"
          CLUSTER_NAME="${{ inputs.cluster_name }}"
          COMMIT_SUFFIX="${{ inputs.commit_message_suffix }}"
          
          # Function to apply our specific changes
          apply_changes() {
            echo "üîß Applying changes for ${APP_NAME} deployment..."
            
            # We expect a root kustomization.yaml in the namespace directory, and will add our app name to the
            # kustomization.yaml if not already present
            NAMESPACE_PATH="${CLUSTER_PATH}/${NAMESPACE}"

            if [ -f "${NAMESPACE_PATH}/kustomization.yaml" ]; then
              if ! grep -q " - ${APP_NAME}$" "${NAMESPACE_PATH}/kustomization.yaml"; then
                cd "${NAMESPACE_PATH}"
                # Just add the app name to the resources list in kustomization.yaml using yq
                yq eval ".resources += [\"${APP_NAME}\"]" -i kustomization.yaml
                echo "‚úÖ Added ${APP_NAME} to kustomization at ${NAMESPACE_PATH}/kustomization.yaml"
                cd -
              else 
                echo "‚ÑπÔ∏è  ${APP_NAME} already present in kustomization at ${NAMESPACE_PATH}/kustomization.yaml"
              fi
            else
              echo "‚ö†Ô∏è  No kustomization.yaml found at ${NAMESPACE_PATH}"
            fi

            # Update image tag
            APP_PATH="${CLUSTER_PATH}/${NAMESPACE}/${APP_NAME}"
            
            # We store our helm values in ${APP_NAME}-values.yaml
            if [ -f "${APP_PATH}/${APP_NAME}-values.yaml" ]; then
              # Check if tag is already current
              CURRENT_TAG=$(yq eval ".image.tag" "${APP_PATH}/${APP_NAME}-values.yaml" 2>/dev/null || echo "none")
              if [ "$CURRENT_TAG" = "$IMAGE_TAG" ]; then
                echo "‚ÑπÔ∏è  Image tag ${IMAGE_TAG} is already current in ${APP_PATH}/${APP_NAME}-values.yaml"
                return 0
              fi
              
              # Update Helm values
              yq eval ".image.tag = \"${IMAGE_TAG}\"" -i "${APP_PATH}/${APP_NAME}-values.yaml"
              echo "‚úÖ Updated Helm values at ${APP_PATH}/${APP_NAME}-values.yaml (${CURRENT_TAG} ‚Üí ${IMAGE_TAG})"
            else
              echo "‚ö†Ô∏è  No values file found at ${APP_PATH}/${APP_NAME}-values.yaml"
            fi
          }
          
          # Function for pull request deployment
          deploy_pull_request() {
            echo "üöÄ Creating pull request deployment for ${CLUSTER_NAME} cluster"
            
            # Always fetch latest changes first
            echo "üì• Fetching latest changes from GitOps repo..."
            git fetch origin main
            git reset --hard origin/main
            
            # Create feature branch
            BRANCH_NAME="deploy/${APP_NAME}/${IMAGE_TAG}-${CLUSTER_NAME}-$(date +%s)"
            git checkout -b "${BRANCH_NAME}"
            
            # Apply our changes
            apply_changes
            
            # Check if there are any changes to commit
            if git diff --quiet && git diff --cached --quiet; then
              echo "‚úÖ No changes to commit - deployment is already current"
              return 0
            fi
            
            # Show what we're about to commit
            echo "üìù Changes to be committed:"
            git diff --name-status
            
            # Commit and push branch
            git add .
            git commit -m "Deploy ${APP_NAME} ${IMAGE_TAG} to ${NAMESPACE} on ${CLUSTER_NAME}${COMMIT_SUFFIX}

            - Image: ${IMAGE_TAG}
            - Triggered by: ${{ github.actor }}
            - Commit: ${{ github.sha }}
            - Workflow: ${{ github.run_id }}"
            
            git push origin "${BRANCH_NAME}"
            
            # Create Pull Request using GitHub CLI
            export GITHUB_TOKEN="${{ secrets.CICD_TOKEN }}"
            
            echo "üìã Creating pull request..."
            gh pr create \
              --repo "${GITOPS_REPO}" \
              --title "Deploy ${APP_NAME} ${IMAGE_TAG} to ${NAMESPACE} (${CLUSTER_NAME} cluster)" \
              --body "Automated deployment PR for ${APP_NAME} version ${IMAGE_TAG}

            **Cluster**: ${CLUSTER_NAME}
            **Image**: \`${IMAGE_TAG}\`
            **Target**: ${NAMESPACE} namespace in ${CLUSTER_PATH}
            **Triggered by**: ${{ github.actor }}
            **Workflow**: ${{ github.run_id }}${COMMIT_SUFFIX}
            
            This PR will be automatically merged after creation." \
              --base main \
              --head "${BRANCH_NAME}"
            
            echo "üîÑ Merging pull request..."
            # Merge the PR immediately and delete the branch
            gh pr merge "${BRANCH_NAME}" --repo "${GITOPS_REPO}" --squash --delete-branch
            
            echo "‚úÖ Created and merged PR for ${CLUSTER_NAME} cluster, branch deleted"
          }
          
          # Clone GitOps repo
          echo "üì• Cloning GitOps repository: ${GITOPS_REPO}"
          git clone https://x-access-token:${{ secrets.CICD_TOKEN }}@github.com/${GITOPS_REPO}.git gitops
          cd gitops
          
          # Configure git
          git config user.name "${{ secrets.CICD_USER_NAME }}"
          git config user.email "${{ secrets.CICD_USER_EMAIL }}"
          
          # Show current state
          echo "üìç Current GitOps repo state:"
          echo "  Branch: $(git branch --show-current)"
          echo "  Last commit: $(git log -1 --oneline)"
          echo "  Target cluster: ${CLUSTER_NAME}"
          echo "  Application: ${APP_NAME}"
          echo "  Image tag: ${IMAGE_TAG}"
          echo "  Namespace: ${NAMESPACE}"
          echo "  Deployment method: pull-request (auto-merge)"
          
          # Execute deployment using pull request method
          if deploy_pull_request; then
            echo "üéâ Pull request deployment completed successfully!"
          else
            echo "üí• Pull request deployment failed"
            exit 1
          fi
