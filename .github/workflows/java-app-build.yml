# Reusable workflow for building and deploying Java Spring Boot applications
# Location: github-workflows repo at .github/workflows/java-app-build.yml

name: Java App Build and Deploy

on:
  workflow_call:
    inputs:
      app_name:
        required: true
        type: string
        description: 'Name of the application'
      java_version:
        default: '21'
        type: string
        description: 'Java version to use'
      maven_profiles:
        default: ''
        type: string
        description: 'Maven profiles to activate (comma-separated)'
      target_clusters:
        default: '[]'
        type: string
        description: 'JSON array of target clusters'
      dockerfile_repo:
        default: 'krystof-io/devops-templates'
        type: string
        description: 'Repository containing shared Dockerfiles'
      dockerfile_path:
        default: 'Dockerfiles/java/spring-boot/Dockerfile'
        type: string
        description: 'Path to Dockerfile within dockerfile_repo'
      base_docker_image:
        default: 'eclipse-temurin:21-jre-alpine'
        type: string
        description: 'Base image for Docker build'
      heap_size:
        default: '512m'
        type: string
        description: 'JVM heap size'
    secrets:
      IMAGE_REGISTRY_USERNAME:
        required: true
      IMAGE_REGISTRY_PASSWORD:
        required: true
      MAVEN_REPO_USERNAME:
        required: true
      MAVEN_REPO_PASSWORD:
        required: true
      SONAR_TOKEN:
        required: true
      SONAR_HOST_URL:
        required: true
      NVD_API_KEY:
        required: true
      S3_CACHE_ACCESS_KEY:
        required: true
      S3_CACHE_SECRET_KEY:
        required: true              
      CICD_TOKEN:
        required: true
      CICD_USER_EMAIL:
        required: true
      CICD_USER_NAME:
        required: true

jobs:
  # Parse cluster configuration and setup matrix
  build:
    runs-on: arc-runners-javadev
    outputs:
      clusters_matrix: ${{ steps.parse.outputs.matrix }}
      has_clusters: ${{ steps.parse.outputs.has_clusters }}
      version: ${{ steps.version.outputs.version }}
      image_tag: ${{ steps.version.outputs.image_tag }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:

      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 #v5
        
      - name: Checkout workflow repo
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 #v5
        with:
          repository: krystof-io/github-workflows
          path: workflow-config
      
      - name: Parse target clusters
        id: parse
        run: |
          cd workflow-config
          # Read cluster config
          CLUSTERS_CONFIG=$(cat config/clusters.yml | yq -o json)
          
          # Parse input clusters
          TARGET_CLUSTERS='${{ inputs.target_clusters }}'
          
          # Build matrix with GitOps repo for each cluster
          MATRIX=$(echo $TARGET_CLUSTERS | jq -c --argjson config "$CLUSTERS_CONFIG" '
            map({
              name: .,
              gitops_repo: $config.clusters[.].gitops_repo,
              cluster_path: $config.clusters[.].cluster_path
            })
          ')
          echo "matrix={\"include\":$MATRIX}" >> $GITHUB_OUTPUT
          
          # Check if we have any clusters to deploy to
          HAS_CLUSTERS=$(echo $TARGET_CLUSTERS | jq 'length > 0')
          echo "has_clusters=$HAS_CLUSTERS" >> $GITHUB_OUTPUT

      - uses: krystof-io/cache@v4.3.0-1.0.0
        with:
          path: ~/.m2/repository
          key: maven-cache-${{ github.run_id }}-${{ github.run_attempt }}
        env:
          RUNS_ON_S3_BUCKET_CACHE: 'runner-caches'
          AWS_ACCESS_KEY_ID: ${{ secrets.S3_CACHE_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.S3_CACHE_SECRET_KEY }}
          RUNS_ON_S3_BUCKET_ENDPOINT: ${{ vars.S3_CACHE_ENDPOINT }}
          RUNS_ON_AWS_REGION: 'default'
          RUNS_ON_S3_FORCE_PATH_STYLE: 'true'

      - name: Initialize Maven settings
        uses: s4u/maven-settings-action@v3.1.0
        with:
          servers: |
            [
            {"id": "private-snapshots", "username": "${{ env.MAVEN_REPO_USERNAME }}", "password": "${{ env.MAVEN_REPO_PASSWORD }}"},
            {"id": "private-releases", "username": "${{ env.MAVEN_REPO_USERNAME }}", "password": "${{ env.MAVEN_REPO_PASSWORD }}"},
            {"id": "nexus", "username": "${{ env.MAVEN_REPO_USERNAME }}", "password": "${{ env.MAVEN_REPO_PASSWORD }}"}
            ]
          mirrors: |
            [
            {"id": "nexus", "name":"nexus", "mirrorOf":"*", "url":"${{ env.MAVEN_REPO_URL }}"}
            ]
          sonatypeSnapshots: true          
        env:
          MAVEN_REPO_USERNAME: ${{ secrets.MAVEN_REPO_USERNAME }}
          MAVEN_REPO_PASSWORD: ${{ secrets.MAVEN_REPO_PASSWORD }}
          MAVEN_REPO_URL: ${{ vars.MAVEN_REPO_URL }}          

      - name: Build and run tests
        run: |
          PROFILES=""
          if [ -n "${{ inputs.maven_profiles }}" ]; then
            PROFILES="-P${{ inputs.maven_profiles }}"
          fi
          mvn clean verify ${PROFILES}

      - name: Calculate version and image tag
        id: version
        run: |
          # Extract version from pom.xml
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout || echo "unknown")
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          
          # Determine if this is a release (tag starting with 'v')
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            IS_RELEASE="true"
            # For releases, use clean version (no SNAPSHOT)
            IMAGE_TAG="${VERSION}"
          elif [[ "${{ github.ref }}" == refs/heads/main ]]; then
            IS_RELEASE="false"
            # For main branch
            IMAGE_TAG="${VERSION}-${SHORT_SHA}"
          else
            IS_RELEASE="false"
            # For feature branches
            BRANCH_NAME=$(echo ${{ github.ref }} | sed 's|refs/heads/||' | sed 's/[^a-zA-Z0-9]/-/g')
            IMAGE_TAG="${VERSION}-${BRANCH_NAME}-${SHORT_SHA}"
          fi
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "is_release=${IS_RELEASE}" >> $GITHUB_OUTPUT
          
          echo "Version: ${VERSION}"
          echo "Image Tag: ${IMAGE_TAG}"
          echo "Is Release: ${IS_RELEASE}"

  # Build Docker image
  build-docker-image:
    runs-on: arc-runners-javadev
    needs: [build]
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 #v5
        
      - name: Checkout dockerfile repo
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 #v5
        with:
          repository: ${{ inputs.dockerfile_repo }}
          path: docker-templates

      - uses: krystof-io/cache@v4.3.0-1.0.0
        with:
          path: ~/.m2/repository
          key: maven-cache-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            maven-cache-          
        env:
          RUNS_ON_S3_BUCKET_CACHE: 'runner-caches'
          AWS_ACCESS_KEY_ID: ${{ secrets.S3_CACHE_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.S3_CACHE_SECRET_KEY }}
          RUNS_ON_S3_BUCKET_ENDPOINT: ${{ vars.S3_CACHE_ENDPOINT }}
          RUNS_ON_AWS_REGION: 'default'
          RUNS_ON_S3_FORCE_PATH_STYLE: 'true'

      - name: Initialize Maven settings
        uses: s4u/maven-settings-action@v3.1.0
        with:
          servers: |
            [
            {"id": "private-snapshots", "username": "${{ env.MAVEN_REPO_USERNAME }}", "password": "${{ env.MAVEN_REPO_PASSWORD }}"},
            {"id": "private-releases", "username": "${{ env.MAVEN_REPO_USERNAME }}", "password": "${{ env.MAVEN_REPO_PASSWORD }}"},
            {"id": "nexus", "username": "${{ env.MAVEN_REPO_USERNAME }}", "password": "${{ env.MAVEN_REPO_PASSWORD }}"}
            ]
          mirrors: |
            [
            {"id": "nexus", "name":"nexus", "mirrorOf":"*", "url":"${{ env.MAVEN_REPO_URL }}"}
            ]
          sonatypeSnapshots: true          
        env:
          MAVEN_REPO_USERNAME: ${{ secrets.MAVEN_REPO_USERNAME }}
          MAVEN_REPO_PASSWORD: ${{ secrets.MAVEN_REPO_PASSWORD }}
          MAVEN_REPO_URL: ${{ vars.MAVEN_REPO_URL }}   

      - name: Package application
        run: |
          PROFILES=""
          if [ -n "${{ inputs.maven_profiles }}" ]; then
            PROFILES="-P${{ inputs.maven_profiles }}"
          fi
          mvn package -DskipTests ${PROFILES}
        env:
          MAVEN_REPO_USERNAME: ${{ secrets.MAVEN_REPO_USERNAME }}
          MAVEN_REPO_PASSWORD: ${{ secrets.MAVEN_REPO_PASSWORD }}
      
      - name: Find JAR file
        id: find_jar
        run: |
          JAR_FILE=$(find target -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" | head -1)
          echo "jar_file=${JAR_FILE}" >> $GITHUB_OUTPUT
          echo "Found JAR: ${JAR_FILE}"
      
      - name: Login to internal private docker repo
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef #v3.6.0
        with:
          registry: ${{ vars.IMAGE_REGISTRY_HOST }}
          username: ${{ secrets.IMAGE_REGISTRY_USERNAME }}
          password: ${{ secrets.IMAGE_REGISTRY_PASSWORD }}
      
      - name: Build and push Docker image
        run: |
          IMAGE_NAME="${{ vars.IMAGE_REGISTRY_HOST }}/krystof-io/${{ inputs.app_name }}:${{ needs.build.outputs.image_tag }}"
          
          docker build \
            -f docker-templates/${{ inputs.dockerfile_path }} \
            --build-arg BASE_IMAGE=${{ inputs.base_docker_image }} \
            --build-arg JAR_FILE=${{ steps.find_jar.outputs.jar_file }} \
            -t "${IMAGE_NAME}" \
            .
          
          docker push "${IMAGE_NAME}"

  # Run Sonar scan (only on main branch)
  sonar-scan:
    runs-on: arc-runners-javadev
    needs: [build]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 #v5
        
      - name: Initialize Maven settings
        uses: s4u/maven-settings-action@v3.1.0
        with:
          servers: |
            [
            {"id": "private-snapshots", "username": "${{ env.MAVEN_REPO_USERNAME }}", "password": "${{ env.MAVEN_REPO_PASSWORD }}"},
            {"id": "private-releases", "username": "${{ env.MAVEN_REPO_USERNAME }}", "password": "${{ env.MAVEN_REPO_PASSWORD }}"},
            {"id": "nexus", "username": "${{ env.MAVEN_REPO_USERNAME }}", "password": "${{ env.MAVEN_REPO_PASSWORD }}"}
            ]
          mirrors: |
            [
            {"id": "nexus", "name":"nexus", "mirrorOf":"*", "url":"${{ env.MAVEN_REPO_URL }}"}
            ]
          sonatypeSnapshots: true          
        env:
          MAVEN_REPO_USERNAME: ${{ secrets.MAVEN_REPO_USERNAME }}
          MAVEN_REPO_PASSWORD: ${{ secrets.MAVEN_REPO_PASSWORD }}
          MAVEN_REPO_URL: ${{ vars.MAVEN_REPO_URL }}  
            
      - uses: krystof-io/cache@v4.3.0-1.0.0
        with:
          path: ~/.m2/repository
          key: maven-cache-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            maven-cache-
        env:
          RUNS_ON_S3_BUCKET_CACHE: 'runner-caches'
          AWS_ACCESS_KEY_ID: ${{ secrets.S3_CACHE_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.S3_CACHE_SECRET_KEY }}
          RUNS_ON_S3_BUCKET_ENDPOINT: ${{ vars.S3_CACHE_ENDPOINT }}
          RUNS_ON_AWS_REGION: 'default'
          RUNS_ON_S3_FORCE_PATH_STYLE: 'true'
                    
      - uses: krystof-io/cache@v4.3.0-1.0.0
        with:
          path: ~/.m2/repository/org/owasp/dependency-check-data
          key: ${{ runner.os }}-owasp-data-${{ hashFiles('**/pom.xml') }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-owasp-data-
        env:
          RUNS_ON_S3_BUCKET_CACHE: 'runner-caches'
          AWS_ACCESS_KEY_ID: ${{ secrets.S3_CACHE_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.S3_CACHE_SECRET_KEY }}
          RUNS_ON_S3_BUCKET_ENDPOINT: ${{ vars.S3_CACHE_ENDPOINT }}
          RUNS_ON_AWS_REGION: 'default'
          RUNS_ON_S3_FORCE_PATH_STYLE: 'true'
          RUNS_ON_GLOBAL_CACHE_PREFIX: 'cache-global' # This gets shared across repos

      - name: Pre Sonar Build
        run: |
          mvn clean verify
                    
      - name: Pre Sonar Dep Check
        run: |
          mvn org.owasp:dependency-check-maven:12.1.8:check \
            -Dformats=HTML,XML,JSON \
            -DnvdApiKey=${{ env.NVD_API_KEY }} \
            -DskipTests 
        env:
          NVD_API_KEY: ${{ secrets.NVD_API_KEY }}

      - name: Sonar Analysis
        run: |
          mvn sonar:sonar \
            -Dsonar.host.url=${{ env.SONAR_HOST_URL }} \
            -Dsonar.token=${{ env.SONAR_TOKEN }}
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}


  # Deploy to dev environment (direct commit)
  deploy-dev:
    runs-on: arc-runners-javadev
    needs: [build, build-docker-image]
    if: github.ref != 'refs/tags/v*' && needs.build.outputs.has_clusters == 'true'
    strategy:
      matrix: ${{ fromJson(needs.build.outputs.clusters_matrix) }}
    steps:
      
      - name: Update GitOps repo with retry logic
        run: |
          set -e
          
          GITOPS_REPO="${{ matrix.gitops_repo }}"
          APP_NAME="${{ inputs.app_name }}"
          NAMESPACE="kio-dev"
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          CLUSTER_PATH="${{ matrix.cluster_path }}"
          CLUSTER_NAME="${{ matrix.name }}"
          
          # Function to apply our specific changes
          apply_changes() {
            echo "üîß Applying changes for ${APP_NAME} deployment..."
            
            # We expect a root kustomization.yaml in the namespace directory, and will add our app name to the
            # kustomization.yaml if not already present
            NAMESPACE_PATH="${CLUSTER_PATH}/${NAMESPACE}"

            if [ -f "${NAMESPACE_PATH}/kustomization.yaml" ]; then
              if ! grep -q " - ${APP_NAME}$" "${NAMESPACE_PATH}/kustomization.yaml"; then
                cd "${NAMESPACE_PATH}"
                # Just add the app name to the resources list in kustomization.yaml using yq
                yq eval ".resources += [\"${APP_NAME}\"]" -i kustomization.yaml
                echo "‚úÖ Added ${APP_NAME} to kustomization at ${NAMESPACE_PATH}/kustomization.yaml"
                cd -
              else 
                echo "‚ÑπÔ∏è  ${APP_NAME} already present in kustomization at ${NAMESPACE_PATH}/kustomization.yaml"
              fi
            else
              echo "‚ö†Ô∏è  No kustomization.yaml found at ${NAMESPACE_PATH}"
            fi

            # Update image tag
            APP_PATH="${CLUSTER_PATH}/${NAMESPACE}/${APP_NAME}"
            
            # We store our helm values in ${APP_NAME}-values.yaml
            if [ -f "${APP_PATH}/${APP_NAME}-values.yaml" ]; then
              # Check if tag is already current
              CURRENT_TAG=$(yq eval ".image.tag" "${APP_PATH}/${APP_NAME}-values.yaml" 2>/dev/null || echo "none")
              if [ "$CURRENT_TAG" = "$IMAGE_TAG" ]; then
                echo "‚ÑπÔ∏è  Image tag ${IMAGE_TAG} is already current in ${APP_PATH}/${APP_NAME}-values.yaml"
                return 0
              fi
              
              # Update Helm values
              yq eval ".image.tag = \"${IMAGE_TAG}\"" -i "${APP_PATH}/${APP_NAME}-values.yaml"
              echo "‚úÖ Updated Helm values at ${APP_PATH}/${APP_NAME}-values.yaml (${CURRENT_TAG} ‚Üí ${IMAGE_TAG})"
            else
              echo "‚ö†Ô∏è  No values file found at ${APP_PATH}/${APP_NAME}-values.yaml"
            fi
          }
          
          # Function to attempt deployment with retry logic
          deploy_with_retry() {
            local max_attempts=5
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "üöÄ Deployment attempt $attempt of $max_attempts for ${CLUSTER_NAME} cluster"
              
              # Always pull latest changes before making modifications
              echo "üì• Fetching latest changes from GitOps repo..."
              git fetch origin main
              git reset --hard origin/main
              
              # Apply our changes
              apply_changes
              
              # Check if there are any changes to commit
              if git diff --quiet && git diff --cached --quiet; then
                echo "‚úÖ No changes to commit - deployment is already current"
                return 0
              fi
              
              # Show what we're about to commit
              echo "üìù Changes to be committed:"
              git diff --name-status
              
              # Commit changes
              git add .
              git commit -m "Deploy ${APP_NAME} ${IMAGE_TAG} to ${NAMESPACE} on ${CLUSTER_NAME} cluster [attempt $attempt]

              - Image: ${IMAGE_TAG}
              - Triggered by: ${{ github.actor }}
              - Commit: ${{ github.sha }}
              - Workflow: ${{ github.run_id }}"
              
              # Try to push
              echo "üì§ Attempting to push changes..."
              if git push origin main; then
                echo "‚úÖ Successfully deployed ${APP_NAME} to ${CLUSTER_NAME} cluster on attempt $attempt"
                return 0
              else
                echo "‚ùå Push failed on attempt $attempt"
                if [ $attempt -lt $max_attempts ]; then
                  # Calculate backoff delay (exponential: 2, 4, 8, 16 seconds)
                  local delay=$((2 ** attempt))
                  echo "‚è≥ Waiting ${delay} seconds before retry..."
                  sleep $delay
                fi
                attempt=$((attempt + 1))
              fi
            done
            
            echo "üí• Failed to deploy after $max_attempts attempts"
            echo "This could indicate:"
            echo "  - High concurrent deployment activity"
            echo "  - Network connectivity issues"
            echo "  - GitOps repository access problems"
            echo "  - Conflicting manual changes in the repository"
            return 1
          }
          
          # Clone GitOps repo
          echo "üì• Cloning GitOps repository: ${GITOPS_REPO}"
          git clone https://x-access-token:${{ secrets.CICD_TOKEN }}@github.com/${GITOPS_REPO}.git gitops
          cd gitops
          
          # Configure git
          git config user.name "${{ secrets.CICD_USER_NAME }}"
          git config user.email "${{ secrets.CICD_USER_EMAIL }}"
          
          # Show current state
          echo "üìç Current GitOps repo state:"
          echo "  Branch: $(git branch --show-current)"
          echo "  Last commit: $(git log -1 --oneline)"
          echo "  Target cluster: ${CLUSTER_NAME}"
          echo "  Application: ${APP_NAME}"
          echo "  Image tag: ${IMAGE_TAG}"
          echo "  Namespace: ${NAMESPACE}"
          
          # Execute deployment with retry logic
          if deploy_with_retry; then
            echo "üéâ Deployment completed successfully!"
          else
            echo "üí• Deployment failed after all retry attempts"
            exit 1
          fi

  # Deploy to prod environment (create PR with auto-merge)
  deploy-prod:
    runs-on: arc-runners-javadev
    needs: [setup, build-docker-image]
    if: startsWith(github.ref, 'refs/tags/v')
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.clusters_matrix) }}
    steps:
      - name: Validate version is not SNAPSHOT
        run: |
          VERSION="${{ needs.setup.outputs.version }}"
          if [[ "${VERSION}" == *"SNAPSHOT"* ]]; then
            echo "ERROR: Cannot deploy SNAPSHOT version to production"
            exit 1
          fi
          echo "‚úÖ Version ${VERSION} is valid for production"
      
      - name: Create GitOps PR
        run: |
          set -e
          
          GITOPS_REPO="${{ matrix.gitops_repo }}"
          APP_NAME="${{ inputs.app_name }}"
          NAMESPACE="kio-prod"
          IMAGE_TAG="${{ needs.setup.outputs.image_tag }}"
          CLUSTER_PATH="${{ matrix.cluster_path }}"
          VERSION="${{ needs.setup.outputs.version }}"
          CLUSTER_NAME="${{ matrix.name }}"
          
          # Clone GitOps repo
          git clone https://x-access-token:${{ secrets.CICD_TOKEN }}@github.com/${GITOPS_REPO}.git gitops
          cd gitops
          
          # Create feature branch
          BRANCH_NAME="deploy/${APP_NAME}/${VERSION}-${CLUSTER_NAME}"
          git checkout -b "${BRANCH_NAME}"
          
          # Update image tag
          APP_PATH="clusters/${CLUSTER_PATH}/namespaces/${NAMESPACE}/${APP_NAME}"
          
          # We store our helm values in ${APP_NAME}-values.yaml
          if [ -f "${APP_PATH}/${APP_NAME}-values.yaml" ]; then
            # Check if tag is already current
            CURRENT_TAG=$(yq eval ".image.tag" "${APP_PATH}/${APP_NAME}-values.yaml" 2>/dev/null || echo "none")
            if [ "$CURRENT_TAG" = "$IMAGE_TAG" ]; then
              echo "‚ÑπÔ∏è  Image tag ${IMAGE_TAG} is already current in ${APP_PATH}/${APP_NAME}-values.yaml"
              return 0
            fi
            
            # Update Helm values
            yq eval ".image.tag = \"${IMAGE_TAG}\"" -i "${APP_PATH}/${APP_NAME}-values.yaml"
            echo "‚úÖ Updated Helm values at ${APP_PATH}/${APP_NAME}-values.yaml (${CURRENT_TAG} ‚Üí ${IMAGE_TAG})"
          else
            echo "‚ö†Ô∏è  No values file found at ${APP_PATH}/${APP_NAME}-values.yaml"
          fi          
          
          # Commit and push branch
          git config user.name "${{ secrets.CICD_USER_NAME }}"
          git config user.email "${{ secrets.CICD_USER_EMAIL }}"
          git add .
          git commit -m "Deploy ${APP_NAME} ${VERSION} to ${NAMESPACE} on ${CLUSTER_NAME}"
          git push origin "${BRANCH_NAME}"
          
          # Create Pull Request using GitHub CLI
          export GITHUB_TOKEN="${{ secrets.CICD_TOKEN }}"
          gh pr create \
            --repo "${GITOPS_REPO}" \
            --title "Deploy ${APP_NAME} ${VERSION} to production (${CLUSTER_NAME} cluster)" \
            --body "Automated deployment PR for ${APP_NAME} version ${VERSION}

**Cluster**: ${CLUSTER_NAME}
**Image**: \`${{ env.IMAGE_REGISTRY_HOST }}/${APP_NAME}:${IMAGE_TAG}\`
**Target**: ${NAMESPACE} namespace in ${CLUSTER_PATH}
**Triggered by**: Tag push in ${APP_NAME} repository
**Tag**: ${{ github.ref }}

This PR will auto-merge once all required checks pass." \
            --base main \
            --head "${BRANCH_NAME}"
          
          # Enable auto-merge
          gh pr merge "${BRANCH_NAME}" --repo "${GITOPS_REPO}" --auto --squash
          
          echo "‚úÖ Created PR for ${{ matrix.name }} cluster (prod) with auto-merge enabled"